{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Portf\u00f3lio \u00b7 Plataformas, Microsservi\u00e7os e APIs","text":"<p>Resumo</p> <p>Este site documenta minha implementa\u00e7\u00e3o dos exerc\u00edcios da disciplina Plataformas, Microsservi\u00e7os, DevOps e APIs (Insper). A ideia \u00e9 mostrar o que eu constru\u00ed, como implementei cada servi\u00e7o e evid\u00eancias (prints / logs / comandos).</p>"},{"location":"#sobre-mim","title":"Sobre mim \ud83d\udc69\u200d\ud83d\udcbb","text":"<ul> <li>Nome: Giovanny Russo </li> <li>Stack principal: Spring Boot, Python (FastAPI), Docker, Jenkins, Kubernetes.</li> </ul>"},{"location":"#arquitetura-de-microsservicos","title":"Arquitetura de Microsservi\u00e7os","text":"Microservice Interface (API / Endpoint P\u00fablico) Implementa\u00e7\u00e3o Auth Auth Auth-Service Account Account Account-Service Order Order Order-Service Product Product Product-Service Gateway Gateway Exchange Exchange"},{"location":"#visao-geral-da-arquitetura","title":"Vis\u00e3o Geral da Arquitetura","text":"<p>A disciplina trabalha com uma arquitetura baseada em microsservi\u00e7os (account-service, auth-service, product-service, order-service, exchange-service), um API Gateway e um banco de dados. Cada microsservi\u00e7o \u00e9 isolado, mas todos se conversam via HTTP dentro de uma camada \"confi\u00e1vel\" (Trusted Layer).</p> <p>```mermaid flowchart LR     subgraph Internet         client[Cliente / Front-end]     end</p> <pre><code>client --&gt; gateway[API Gateway]\n\nsubgraph \"Trusted Layer\"\n    gateway --&gt; account[account-service]\n    gateway --&gt; auth[auth-service]\n    gateway --&gt; product[product-service]\n    gateway --&gt; order[order-service]\n    gateway --&gt; exchange[exchange-service (Python)]\n    account --&gt; db[(Database)]\n    product --&gt; db\n    order --&gt; db\n    order --&gt; product\n    exchange --&gt; extAPI[(3rd-party FX API)]\nend\n</code></pre>"},{"location":"exercicio1/","title":"Exerc\u00edcio 1 \u00b7 Product API","text":"<p>Objetivo oficial</p> <p>Criar um microsservi\u00e7o independente para gerenciar produtos de uma loja, utilizando arquitetura de microsservi\u00e7os. O servi\u00e7o deve expor uma API REST com opera\u00e7\u00f5es b\u00e1sicas de CRUD (sem atualiza\u00e7\u00e3o), persistir os dados e ser acessado via Gateway protegido por autentica\u00e7\u00e3o.</p>"},{"location":"exercicio1/#link-dos-repositorios","title":"link Dos reposit\u00f3rios","text":"<p>Product </p> <p>Product-Service</p>"},{"location":"exercicio1/#o-que-foi-implementado","title":"O que foi implementado","text":"<p>Este microsservi\u00e7o (<code>product-service</code>) atende integralmente ao que foi solicitado no exerc\u00edcio proposto:</p> <ul> <li>A API permite:</li> <li>Cadastrar produtos com nome, pre\u00e7o e unidade;</li> <li>Listar todos os produtos cadastrados;</li> <li>Buscar um produto espec\u00edfico por ID;</li> <li> <p>Remover um produto pelo ID.</p> </li> <li> <p>Os dados s\u00e3o persistidos em banco de dados por meio de uma entidade <code>Product</code>, com identificador do tipo UUID.</p> </li> <li> <p>O servi\u00e7o foi implementado como um microsservi\u00e7o aut\u00f4nomo, com endpoints REST expostos via <code>Spring Boot</code>, estruturado em camadas (controller, service, repository).</p> </li> <li> <p>A API est\u00e1 integrada ao Gateway, que protege as rotas com autentica\u00e7\u00e3o e valida tokens JWT antes de permitir o acesso.</p> </li> </ul>"},{"location":"exercicio1/#endpoints-implementados","title":"Endpoints implementados","text":"<p>Todos os endpoints seguem o prefixo base <code>/products</code>:</p> M\u00e9todo HTTP Rota Fun\u00e7\u00e3o <code>POST</code> <code>/products</code> Cadastra um novo produto. <code>GET</code> <code>/products</code> Lista todos os produtos existentes. <code>GET</code> <code>/products/{id}</code> Retorna um produto espec\u00edfico por ID. <code>DELETE</code> <code>/products/{id}</code> Remove um produto pelo ID informado."},{"location":"exercicio1/#observacoes-finais","title":"Observa\u00e7\u00f5es finais","text":"<p>Todos os requisitos propostos no enunciado foram cumpridos: - Os endpoints obrigat\u00f3rios est\u00e3o dispon\u00edveis. - O servi\u00e7o persiste os dados corretamente. - A autentica\u00e7\u00e3o via gateway est\u00e1 funcionando como camada intermedi\u00e1ria de prote\u00e7\u00e3o da API.</p> <p>O <code>product-service</code> est\u00e1 pronto para ser consumido por outros microsservi\u00e7os ou front-ends conectados \u00e0 arquitetura.</p>"},{"location":"exercicio2/","title":"Exerc\u00edcio 2 \u00b7 Order API","text":"<p>Objetivo oficial</p> <p>Desenvolver um microsservi\u00e7o para representar pedidos de compra (ordens), conectando-se a outros servi\u00e7os como o <code>product-service</code>. A API deve permitir criar pedidos com m\u00faltiplos produtos, listar pedidos existentes e consultar um pedido por ID. O servi\u00e7o deve persistir os dados, estar protegido por autentica\u00e7\u00e3o e ser acessado via Gateway.</p>"},{"location":"exercicio2/#links-dos-repositorios","title":"Links dos reposit\u00f3rios","text":"<p>Order Order-Service</p>"},{"location":"exercicio2/#o-que-foi-implementado","title":"O que foi implementado","text":"<p>O microsservi\u00e7o <code>order-service</code> foi desenvolvido para gerenciar ordens de compra dentro do ecossistema de microsservi\u00e7os da aplica\u00e7\u00e3o.</p> <p>Ele cumpre todos os requisitos do exerc\u00edcio proposto:</p> <ul> <li>Permite:</li> <li>Criar um pedido, com m\u00faltiplos produtos e suas respectivas quantidades;</li> <li>Listar todos os pedidos existentes, com detalhes de produtos inclu\u00eddos;</li> <li> <p>Buscar um pedido espec\u00edfico por ID e visualizar seu conte\u00fado completo.</p> </li> <li> <p>Cada pedido \u00e9 composto por:</p> </li> <li>Identificador \u00fanico (<code>id</code>)</li> <li>Lista de produtos (<code>productId</code>, quantidade, valor)</li> <li>Status do pedido (<code>OPEN</code>, <code>CONFIRMED</code>, etc.)</li> <li> <p>Timestamp de cria\u00e7\u00e3o</p> </li> <li> <p>O servi\u00e7o persiste os pedidos em banco de dados usando Spring Data JPA.</p> </li> <li> <p>A l\u00f3gica de neg\u00f3cio consulta o <code>product-service</code> para obter dados reais de produto e calcular corretamente o valor total dos pedidos.</p> </li> <li> <p>A API est\u00e1 integrada ao Gateway, que protege o acesso com autentica\u00e7\u00e3o via JWT.</p> </li> </ul>"},{"location":"exercicio2/#endpoints-implementados","title":"Endpoints implementados","text":"<p>Todos os endpoints seguem o prefixo base <code>/orders</code>:</p> M\u00e9todo HTTP Rota Fun\u00e7\u00e3o <code>POST</code> <code>/orders</code> Cria um novo pedido com m\u00faltiplos produtos. <code>GET</code> <code>/orders</code> Lista todos os pedidos j\u00e1 registrados. <code>GET</code> <code>/orders/{id}</code> Retorna os detalhes completos de um pedido."},{"location":"exercicio2/#observacoes-finais","title":"Observa\u00e7\u00f5es finais","text":"<p>Todos os requisitos propostos no exerc\u00edcio foram cumpridos:</p> <ul> <li>O servi\u00e7o aceita m\u00faltiplos produtos por pedido e busca os dados reais desses produtos no <code>product-service</code>.</li> <li>Os pedidos s\u00e3o persistidos corretamente no banco de dados.</li> <li>A API segue boas pr\u00e1ticas REST, com uso de <code>POST</code>, <code>GET</code> e status HTTP adequados.</li> <li>O acesso ao servi\u00e7o est\u00e1 protegido via Gateway, com autentica\u00e7\u00e3o de usu\u00e1rios.</li> </ul> <p>O <code>order-service</code> est\u00e1 pronto para integrar o fluxo de compra completo da aplica\u00e7\u00e3o, servindo como elo entre o cliente final e o cat\u00e1logo de produtos.</p>"},{"location":"exercicio3/","title":"Exerc\u00edcio 3 \u00b7 Exchange API","text":"<p>Objetivo oficial</p> <p>Criar um microsservi\u00e7o independente para realizar convers\u00e3o entre moedas, utilizando dados de uma API externa ou fonte local. A API deve permitir consultar a taxa de c\u00e2mbio entre duas moedas e converter valores com base nessa taxa. O acesso \u00e0 API deve ser feito via Gateway com autentica\u00e7\u00e3o.</p>"},{"location":"exercicio3/#links-dos-repositorios","title":"Links dos reposit\u00f3rios","text":"<p>Exchange </p>"},{"location":"exercicio3/#o-que-foi-implementado","title":"O que foi implementado","text":"<p>Implementei o microsservi\u00e7o <code>exchange-api</code>, respons\u00e1vel por realizar opera\u00e7\u00f5es de c\u00e2mbio (convers\u00e3o de valores entre moedas) no ecossistema da aplica\u00e7\u00e3o.</p> <p>Este servi\u00e7o cumpre integralmente os requisitos propostos no exerc\u00edcio:</p> <ul> <li>Permite:</li> <li>Consultar a taxa de c\u00e2mbio entre duas moedas espec\u00edficas;</li> <li> <p>Converter um valor de uma moeda para outra usando a taxa correspondente.</p> </li> <li> <p>A API exp\u00f5e dois endpoints principais:</p> </li> <li>Um <code>GET</code> para retornar a taxa atual entre duas moedas;</li> <li> <p>Um <code>POST</code> para realizar a convers\u00e3o de valores.</p> </li> <li> <p>O servi\u00e7o pode usar:</p> </li> <li>Uma API externa de c\u00e2mbio, como fonte de taxa (Ex: OpenExchange, AwesomeAPI, etc);</li> <li> <p>Ou uma tabela local simulada de taxas (em modo offline/teste).</p> </li> <li> <p>O acesso \u00e0 API est\u00e1 protegido via Gateway, que realiza a autentica\u00e7\u00e3o por JWT antes de encaminhar as requisi\u00e7\u00f5es.</p> </li> </ul>"},{"location":"exercicio3/#endpoints-implementados","title":"Endpoints implementados","text":"<p>Todos os endpoints seguem o prefixo base <code>/exchange</code>.</p> M\u00e9todo HTTP Rota Fun\u00e7\u00e3o <code>GET</code> <code>/exchange/rate?from=USD&amp;to=BRL</code> Retorna a taxa de c\u00e2mbio da moeda <code>from</code> para <code>to</code>. <code>POST</code> <code>/exchange/convert</code> Recebe um valor e converte de <code>from</code> para <code>to</code>."},{"location":"exercicio3/#exemplo-de-uso","title":"Exemplo de uso","text":""},{"location":"exercicio3/#get-exchangerate","title":"<code>GET /exchange/rate</code>","text":"<p>```http GET /exchange/rate?from=USD&amp;to=EUR Authorization: Bearer"},{"location":"exercicio4/","title":"Exerc\u00edcio 4 \u00b7 Jenkins / CI\u2011CD","text":"<p>Objetivo oficial</p> <p>Automatizar o processo de build, teste e empacotamento de todos os microsservi\u00e7os da aplica\u00e7\u00e3o, utilizando o Jenkins como ferramenta de Integra\u00e7\u00e3o Cont\u00ednua (CI). Cada reposit\u00f3rio deve conter um arquivo <code>Jenkinsfile</code> que descreve as etapas do pipeline de build e gera\u00e7\u00e3o de imagens Docker, garantindo que o sistema permane\u00e7a est\u00e1vel e funcional a cada altera\u00e7\u00e3o no c\u00f3digo.</p>"},{"location":"exercicio4/#links-dos-repositorios","title":"Links dos reposit\u00f3rios","text":"<p>Product-Service Order-Service Auth-Service Account-Service Gateway-Service Exchange-API</p>"},{"location":"exercicio4/#o-que-foi-implementado","title":"O que foi implementado","text":"<p>Implementei a automa\u00e7\u00e3o de build e deploy cont\u00ednuo para todos os microsservi\u00e7os do sistema. Cada reposit\u00f3rio possui seu pr\u00f3prio <code>Jenkinsfile</code>, respons\u00e1vel por definir as etapas de compila\u00e7\u00e3o, teste e gera\u00e7\u00e3o da imagem Docker do servi\u00e7o.</p> <p>O Jenkins foi configurado localmente em <code>http://localhost:9080</code>, e cada microsservi\u00e7o possui uma pipeline independente, garantindo:</p> <ul> <li>Build automatizado: compila\u00e7\u00e3o e empacotamento do c\u00f3digo-fonte em container Docker;  </li> <li>Testes automatizados: execu\u00e7\u00e3o dos testes unit\u00e1rios (quando aplic\u00e1vel) antes de gerar a imagem;  </li> <li>Feedback visual: monitoramento de sucesso/falha diretamente na interface do Jenkins;  </li> <li>Hist\u00f3rico de builds: registro das \u00faltimas execu\u00e7\u00f5es com status e logs acess\u00edveis;  </li> <li>Isolamento entre servi\u00e7os: cada pipeline \u00e9 executada separadamente, evitando interfer\u00eancia entre builds.</li> </ul>"},{"location":"exercicio4/#estrutura-do-jenkinsfile","title":"Estrutura do <code>Jenkinsfile</code>","text":"<p>Cada reposit\u00f3rio inclui um arquivo <code>Jenkinsfile</code> na raiz, que descreve as etapas de build. Abaixo um exemplo real do <code>product-service</code>:</p> <pre><code>pipeline {\n    agent any\n\n    stages {\n        stage('Build') {\n            steps {\n                sh 'mvn clean install'\n            }\n        }\n\n        stage('Docker Build') {\n            steps {\n                sh 'docker build -t product-service .'\n            }\n        }\n\n        stage('Publish') {\n            steps {\n                echo 'Build finalizado com sucesso!'\n            }\n        }\n    }\n}\n\n\nCada microsservi\u00e7o cont\u00e9m:\n\n* **`Dockerfile`** \u2192 descreve a cria\u00e7\u00e3o da imagem do servi\u00e7o;\n* **`Jenkinsfile`** \u2192 define o pipeline de build automatizado;\n* **`src/`** \u2192 cont\u00e9m o c\u00f3digo-fonte principal do servi\u00e7o;\n* **`pom.xml`** ou **`requirements.txt`** \u2192 define as depend\u00eancias do projeto.\n\n| Microsservi\u00e7o   | Jenkinsfile | Dockerfile | Status no Jenkins |\n| --------------- | ----------- | ---------- | ----------------- |\n| Product-Service | \u2705           | \u2705          | \u2705 Build est\u00e1vel   |\n| Order-Service   | \u2705           | \u2705          | \u2705 Build est\u00e1vel   |\n| Auth-Service    | \u2705           | \u2705          | \u2705 Build est\u00e1vel   |\n| Account-Service | \u2705           | \u2705          | \u2705 Build est\u00e1vel   |\n| Gateway-Service | \u2705           | \u2705          | \u2705 Build est\u00e1vel   |\n| Exchange-API    | \u2705           | \u2705          | \u2705 Build est\u00e1vel   |\n\n---\n\n## Execu\u00e7\u00e3o e monitoramento\n\nAp\u00f3s o push de cada reposit\u00f3rio no GitHub, o Jenkins executa automaticamente a pipeline correspondente.\nCada build gera logs e resultados detalhados, podendo ser reexecutado manualmente caso necess\u00e1rio.\n\nA tela principal do Jenkins mostra todas as pipelines configuradas:\n\n![Pipelines do Jenkins](./assets/images/ex4.png)\n\n* Cada linha representa um microsservi\u00e7o independente;\n* O \u00edcone \u2600\ufe0f indica build est\u00e1vel e sem falhas recentes;\n* A coluna **\u201c\u00daltimo Sucesso\u201d** confirma o build mais recente conclu\u00eddo corretamente;\n* A coluna **\u201c\u00daltima Falha\u201d** registra quando o servi\u00e7o apresentou erro (antes da corre\u00e7\u00e3o).\n\n---\n\n## Observa\u00e7\u00f5es finais\n\nO ambiente de **CI/CD** foi configurado com sucesso:\n\n* Todos os microsservi\u00e7os possuem `Jenkinsfile` funcional;\n* Jenkins realiza build e valida\u00e7\u00e3o autom\u00e1tica de cada servi\u00e7o;\n* Pipelines s\u00e3o simples, limpas e seguem boas pr\u00e1ticas de Integra\u00e7\u00e3o Cont\u00ednua;\n* O hist\u00f3rico de builds demonstra estabilidade e corre\u00e7\u00e3o de falhas passadas.\n\nEssa implementa\u00e7\u00e3o garante **reprodutibilidade, automa\u00e7\u00e3o e qualidade cont\u00ednua** em todas as etapas do desenvolvimento da aplica\u00e7\u00e3o.\n</code></pre>"},{"location":"exercicio5/","title":"Exerc\u00edcio \u00b7 Minikube / Kubernetes Local","text":"<p>Objetivo oficial</p> <p>Utilizar o ambiente local com Minikube (ou cluster Kubernetes equivalente) para deployment de microsservi\u00e7os. O objetivo \u00e9 demonstrar que os microsservi\u00e7os desenvolvidos (product\u2011service, order\u2011service, auth\u2011service, gateway, etc) podem subir em Kubernetes local, com os manifests adequados (Deployment, Service, ConfigMap, Secret) e configurar corretamente as depend\u00eancias entre servi\u00e7os.</p>"},{"location":"exercicio5/#o-que-foi-implementado","title":"\u2705 O que foi implementado","text":"<p>Todos os microsservi\u00e7os foram adaptados para rodar corretamente em um cluster Kubernetes local (via Minikube). Os principais pontos implementados foram:</p> <ul> <li>Manifests YAML completos (<code>Deployment</code> + <code>Service</code>) para cada microsservi\u00e7o.</li> <li>Uso de imagens Docker customizadas publicadas no DockerHub (ex: <code>giovannyjvr/order:latest</code>).</li> <li>Configura\u00e7\u00e3o de vari\u00e1veis de ambiente via <code>ConfigMap</code> e <code>Secret</code>, permitindo seguran\u00e7a e flexibilidade.</li> <li>Recursos limitados por container (<code>cpu</code> e <code>mem\u00f3ria</code>) para controle de consumo.</li> <li>Comunica\u00e7\u00e3o entre microsservi\u00e7os feita por nomes DNS internos (ex: <code>product-service</code>, <code>auth-service</code>, etc).</li> <li>Exposi\u00e7\u00e3o do <code>gateway-service</code> como ponto de entrada externo via <code>NodePort</code>.</li> </ul>"},{"location":"exercicio5/#repositorios-ativados","title":"\ud83d\udce6 Reposit\u00f3rios ativados","text":"Microsservi\u00e7o Reposit\u00f3rio GitHub Auth Auth-Service Account Account-Service Order Order-Service Product Product-Service Gateway Gateway-Service"},{"location":"exercicio5/#estrutura-de-arquivos","title":"\ud83d\udcc1 Estrutura de arquivos","text":"<p>Cada servi\u00e7o possui um diret\u00f3rio <code>k8s/</code> contendo o manifest:</p> <pre><code>api/\n\u2514\u2500\u2500 account-service/\n    \u2514\u2500\u2500 k8s/\n        \u2514\u2500\u2500 k8s.yaml\n</code></pre>"},{"location":"exercicio5/#exemplo-de-manifest-order-service","title":"\ud83d\udcc4 Exemplo de manifest (Order Service)","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: order\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: order\n  template:\n    metadata:\n      labels:\n        app: order\n    spec:\n      containers:\n        - name: order\n          image: giovannyjvr/order:latest\n          imagePullPolicy: Always\n          ports:\n            - containerPort: 8080\n          env:\n            - name: POSTGRES_DB\n              valueFrom:\n                configMapKeyRef:\n                  name: postgres-configmap\n                  key: POSTGRES_DB\n            - name: DATABASE_USERNAME\n              valueFrom:\n                secretKeyRef:\n                  name: postgres-secrets\n                  key: POSTGRES_USER\n            - name: DATABASE_PASSWORD\n              valueFrom:\n                secretKeyRef:\n                  name: postgres-secrets\n                  key: POSTGRES_PASSWORD\n            - name: DATABASE_URL\n              value: \"jdbc:postgresql://postgres:5432/$(POSTGRES_DB)\"\n          resources:\n            requests:\n              memory: \"200Mi\"\n              cpu: \"50m\"\n            limits:\n              memory: \"300Mi\"\n              cpu: \"200m\"\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: order\n  labels:\n    app: order\nspec:\n  type: ClusterIP\n  ports:\n    - port: 80\n      protocol: TCP\n      targetPort: 8080\n  selector:\n    app: order\n</code></pre>"}]}